module XmlViewHelper
  # goes through each XML location and marks which errors that location is associated with
  def match_xml_locations_to_error_ids(doc, errors)
    uuid = UUID.new
    error_map = {}        # error_map[error_location] == xml_element_error_id
    error_attributes = [] # only gives error attribute if element has class Nokogiri::XML::Attr
    locations = errors.collect(&:location).compact

    locations.each do |location|
      # Get rid of some funky stuff generated by schematron
      clean_location = location.gsub("[namespace-uri()='urn:hl7-org:v3']", '')
      elem = doc.at_xpath(clean_location)
      next unless elem
      if elem.class == Nokogiri::XML::Attr
        error_attributes << elem
        elem = elem.element
      end
      error_map[location] = get_error_id(elem, uuid)
    end

    [error_map, error_attributes]
  end

  # for each file in the test_execution, matches XML locations to error ids
  #   then returns an object containing the error_maps, error_attributes, and file_errors for each file
  def get_error_mapping(test_execution)
    error_mapping = []
    unless test_execution.new_record?
      test_execution.artifact.each_file do |name, data|
        doc = data_to_doc(data)
        file_errors = test_execution.execution_errors.where(file_name: name)
        error_map, error_attributes = match_xml_locations_to_error_ids(doc, file_errors)
        error_mapping << { doc: doc, error_map: error_map, error_attributes: error_attributes, file: name, file_errors: file_errors }
      end
    end
    error_mapping
  end

  # used for errors popup in node partial
  #   returns title of popup, popup button text, and message in popup
  def popup_attributes(errors)
    multiple_errors = errors.count > 1

    title = 'Execution Error'
    title << "s (#{errors.count})" if multiple_errors

    button_text = ' view error'
    button_text << "s (#{errors.count})" if multiple_errors

    message = ''
    if multiple_errors
      errors.each do |error|
        # error_#{error.id} class is added so error can be highlighted if popup contains multiple errors
        message << "<li class = 'error_#{error.id}'>#{error.message}</li>"
      end
    else
      message << errors.first.message
    end

    [title, button_text, message]
  end

  private

  NODE_TYPES = {
    1 => :element, 2 => :attribute, 3 => :text, 4 => :cdata, 5 => :ent_ref, 6 => :entity,
    7 => :instruction, 8 => :comment, 9 => :document, 10 => :doc_type, 11 => :doc_frag, 12 => :notaion
  }.freeze

  def get_error_id(element, uuid)
    element = element.root if node_type(element.type) == :document
    element['error_id'] = uuid.generate.to_s unless element['error_id']
    element['error_id']
  end

  def node_type(type)
    NODE_TYPES[type]
  end

  def data_to_doc(data)
    if data.is_a? String
      Nokogiri::XML(data)
    else
      data
    end
  end
end
