module RecordsHelper
  SECTIONS = %w[adverse_event allergy assessment care_experience care_goal communication condition
                device diagnostic_study encounter family_history functional_status immunization intervention
                laboratory_test medical_equipment medication physical_exam preference provider_characteristic
                procedure result risk_category_assessment social_history substance symptom system_characteristic
                transfer vital_sign].freeze
  FIELDS = %w[name principalDiagnosis values dose dischargeDisposition route
              administrationTiming fulfillmentHistory reason direction ordinality
              transferFrom laterality anatomical_location diagnosis].freeze
  SUBFIELDS = %w[title scalar value unit units description period dispenseDate quantityDispensed time].freeze
  CV_POPULATION_KEYS = %w[IPP MSRPOPL MSRPOPLEX OBSERV].freeze
  PROPORTION_POPULATION_KEYS = %w[IPP DENOM NUMER DENEX DENEXCEP].freeze

  def full_gender_name(gender)
    case gender
    when 'M'
      'Male'
    when 'F'
      'Female'
    else
      ''
    end
  end

  def full_name(patient)
    patient.givenNames.join(' ') + ' ' + patient.familyName if patient
  end

  # This method takes a set of result values (as generated by get_result_values)
  # and merges all of the values down to
  # Example input:
  #  {BSON::ObjectId('1')=>{"IPP"=>1, "DENOM"=>0, "DENEX"=>0, "NUMER"=>0, "DENEXCEP"=>0},
  #  BSON::ObjectId('2')=>{"IPP"=>1, "DENOM"=>0, "DENEX"=>0, "NUMER"=>0, "DENEXCEP"=>0},
  #  BSON::ObjectId('3')=>{"IPP"=>1, "DENOM"=>0, "DENEX"=>0, "NUMER"=>0, "DENEXCEP"=>0},}
  #
  # Example output:
  # {"IPP"=>3, "DENOM"=>0, "DENEX"=>0, "NUMER"=>0, "DENEXCEP"=>0}
  def pop_sums(result_values)
    result_values.values.inject do |sum, next_elem|
      sum.merge(next_elem) { |_, key1, key2| key1 + key2 }
    end
  end

  # This method returns a hash of the form
  #  {BSON::ObjectId('1')=>{"IPP"=>1, "DENOM"=>0, "DENEX"=>0, "NUMER"=>0, "DENEXCEP"=>0},
  #  BSON::ObjectId('2')=>{"IPP"=>1, "DENOM"=>0, "DENEX"=>0, "NUMER"=>0, "DENEXCEP"=>0},
  #  BSON::ObjectId('3')=>{"IPP"=>1, "DENOM"=>0, "DENEX"=>0, "NUMER"=>0, "DENEXCEP"=>0},}
  #
  # Inputs:
  # records: An array of records (If you only care about a single record then pass in [record])
  # measures: An array of measures (If you only care about a single measure then pass in [measure])
  # pop_set: The population set identifier for the result set you care about, for example ['PopulationCriteria1']
  # pop_keys: The population keys which you care about, for example ['IPP', 'DENOM']
  # key: The name of the element which should be the key of the key value pair returned.
  # We currently use 'patient_id' and 'measure_id' as keys and then do lookups for the values
  # in the hash when generating miscellaneous views around the Master Patient List.
  #
  # Usage tip: It is strongly recommended you pass in either an array of records OR and array
  # of measures and then pass in the other as an array containing a single element.
  def get_result_values(records, measures, pop_set, pop_keys, key)
    CQM::IndividualResult.where(
      :patient_id.in => records.collect(&:id),
      :measure_id.in => measures.collect(&:id),
      :population_set_key => pop_set
    ).collect do |elem|
      [
        elem[key],
        pop_keys.collect { |pop_key| [pop_key, elem[pop_key].to_i] }.to_h
      ]
    end.to_h
  end

  # This method returns a hash of the form
  #  {BSON::ObjectId('1')=>{"IPP"=>1, "DENOM"=>0, "DENEX"=>0, "NUMER"=>0, "DENEXCEP"=>0},
  #  BSON::ObjectId('2')=>{"IPP"=>1, "DENOM"=>0, "DENEX"=>0, "NUMER"=>0, "DENEXCEP"=>0},
  #  BSON::ObjectId('3')=>{"IPP"=>1, "DENOM"=>0, "DENEX"=>0, "NUMER"=>0, "DENEXCEP"=>0},}
  #
  # Inputs:
  # correlation_id: The correlation_id used when performing the measure calculation, most like, the test exection id
  # file_name: The file name for the results you are looking for.
  # measures: An array of measures (If you only care about a single measure then pass in [measure])
  # pop_set: The population set identifier for the result set you care about, for example ['PopulationCriteria1']
  # pop_keys: The population keys which you care about, for example ['IPP', 'DENOM']
  # key: The name of the element which should be the key of the key value pair returned.
  # We currently use 'patient_id' and 'measure_id' as keys and then do lookups for the values
  # in the hash when generating miscellaneous views around the Master Patient List.
  #
  # Usage tip: It is strongly recommended you pass in either an array of records OR and array
  # of measures and then pass in the other as an array containing a single element.
  def get_result_values_test_upload(correlation_id, file_name, measures, pop_set, pop_keys, key)
    CQM::IndividualResult.where(
      :correlation_id => correlation_id,
      :file_name => file_name,
      :measure_id.in => measures.collect(&:id),
      :population_set_key => pop_set
    ).collect do |elem|
      [
        elem[key],
        pop_keys.collect { |pop_key| [pop_key, elem[pop_key].to_i] }.to_h
      ]
    end.to_h
  end

  def records_by_measure(records, measure)
    # Returns array of records that have at least one calculation result for the given measure id
    records.includes(:calculation_results).reject do |r|
      r.calculation_results.select { |c| c['measure'].eql?(measure.id) }.empty?
    end
  end

  def display_field(field)
    display_text = ''
    return '' if field.nil?
    return field if field.is_a? String
    return display_time(field) + "\n" if field.is_a? Integer

    if field.is_a? Array
      field.each { |sub| display_text += display_field(sub) + "\n" }
    else
      field.each do |key, subfield|
        display_text += display_field(subfield) + ' ' if SUBFIELDS.include? key
      end
      field['codes']&.each do |code_system_oid, code|
        display_text += "\n" + code_system_oid + ': ' + code.join(', ')
      end
      display_text += "\n" + field['code_system_oid'] + ': ' + field['code'] if field['code_system_oid']
    end
    display_text
  end

  def hide_patient_calculation?
    # Hide measure calculation if Cypress is in ATL Mode and the current user is not an ATL or admin
    Settings.current.mode_atl? && (!current_user.user_role?('admin') && !current_user.user_role?('atl'))
  end

  def population_label(bundle, pop)
    bundle.modified_population_labels && bundle.modified_population_labels[pop] ? bundle.modified_population_labels[pop] : pop
  end

  def measure_display_name(measure, population_set_hash)
    cms_id = measure.cms_id
    population_set_display = population_set_hash[:stratification_id] || population_set_hash[:population_set_id]
    "#{cms_id} - #{population_set_display.tr('_', ' ')}"
  end
end
