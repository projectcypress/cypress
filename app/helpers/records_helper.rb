module RecordsHelper
  SECTIONS = %w[adverse_event allergy assessment care_experience care_goal communication condition
                device diagnostic_study encounter family_history functional_status immunization intervention
                laboratory_test medical_equipment medication physical_exam preference provider_characteristic
                procedure result risk_category_assessment social_history substance symptom system_characteristic
                transfer vital_sign].freeze
  FIELDS = %w[name principalDiagnosis values dose dischargeDisposition route
              administrationTiming fulfillmentHistory reason direction ordinality
              transferFrom laterality anatomical_location diagnosis].freeze
  SUBFIELDS = %w[title scalar value unit units description period dispenseDate quantityDispensed time].freeze
  CV_POPULATION_KEYS = %w[IPP MSRPOPL MSRPOPLEX OBSERV].freeze
  PROPORTION_POPULATION_KEYS = %w[IPP DENOM NUMER NUMEX DENEX DENEXCEP].freeze
  RATIO_POPULATION_KEYS = %w[IPP DENOM NUMER DENEX DENEXCEP OBSERV].freeze

  def full_gender_name(gender)
    case gender
    when 'M'
      'Male'
    when 'F'
      'Female'
    else
      ''
    end
  end

  def full_name(patient)
    patient.givenNames.join(' ') + ' ' + patient.familyName if patient
  end

  # This method takes a set of result values (as generated by get_result_values)
  # and merges all of the values down to
  # Example input:
  #  {BSON::ObjectId('1')=>{"IPP"=>1, "DENOM"=>0, "DENEX"=>0, "NUMER"=>0, "DENEXCEP"=>0},
  #  BSON::ObjectId('2')=>{"IPP"=>1, "DENOM"=>0, "DENEX"=>0, "NUMER"=>0, "DENEXCEP"=>0},
  #  BSON::ObjectId('3')=>{"IPP"=>1, "DENOM"=>0, "DENEX"=>0, "NUMER"=>0, "DENEXCEP"=>0},}
  #
  # Example output:
  # {"IPP"=>3, "DENOM"=>0, "DENEX"=>0, "NUMER"=>0, "DENEXCEP"=>0}
  def pop_sums(result_values)
    result_values.values.inject do |sum, next_elem|
      sum.merge(next_elem) { |_, key1, key2| key1 + key2 }
    end
  end

  # This method returns a hash of the form
  #  {BSON::ObjectId('1')=>{"IPP"=>1, "DENOM"=>0, "DENEX"=>0, "NUMER"=>0, "DENEXCEP"=>0},
  #  BSON::ObjectId('2')=>{"IPP"=>1, "DENOM"=>0, "DENEX"=>0, "NUMER"=>0, "DENEXCEP"=>0},
  #  BSON::ObjectId('3')=>{"IPP"=>1, "DENOM"=>0, "DENEX"=>0, "NUMER"=>0, "DENEXCEP"=>0},}
  #
  # Inputs:
  # records: An array of records (If you only care about a single record then pass in [record])
  # measures: An array of measures (If you only care about a single measure then pass in [measure])
  # pop_set: The population set identifier for the result set you care about, for example ['PopulationCriteria1']
  # pop_keys: The population keys which you care about, for example ['IPP', 'DENOM']
  # key: The name of the element which should be the key of the key value pair returned.
  # We currently use 'patient_id' and 'measure_id' as keys and then do lookups for the values
  # in the hash when generating miscellaneous views around the Master Patient List.
  #
  # Usage tip: It is strongly recommended you pass in either an array of records OR an array
  # of measures (this should match the key) as resulting hash includes a single key value.
  def get_result_values(records, measures, pop_set, pop_keys, key)
    CQM::IndividualResult.where(
      :patient_id.in => records.pluck(:id),
      :measure_id.in => measures.pluck(:id),
      :population_set_key => pop_set
    ).only(:IPP, :DENOM, :NUMER, :NUMEX, :DENEX, :DENEXCEP, :MSRPOPL, :OBSERV, :MSRPOPLEX, :patient_id, :measure_id).collect do |elem|
      [
        elem[key],
        pop_keys.collect { |pop_key| [pop_key, elem[pop_key].to_i] }.to_h
      ]
    end.to_h
  end

  # This method returns a hash of the form
  #  {BSON::ObjectId('1')=>[[75]],
  #  BSON::ObjectId('2')=>[[]],
  #  BSON::ObjectId('3')=>[[50][10]]}
  #
  # Inputs:
  # records: An array of records (If you only care about a single record then pass in [record])
  # measures: An array of measures (If you only care about a single measure then pass in [measure])
  # pop_set: The population set identifier for the result set you care about, for example ['PopulationCriteria1']
  # key: The name of the element which should be the key of the key value pair returned.
  # We currently use 'patient_id' and 'measure_id' as keys and then do lookups for the values
  # in the hash when generating miscellaneous views around the Master Patient List.
  #
  # Usage tip: It is strongly recommended you pass in either an array of records OR an array
  # of measures (this should match the key) as resulting hash includes a single key value.
  def get_observation_values(records, measures, pop_set, key)
    CQM::IndividualResult.where(
      :patient_id.in => records.pluck(:id),
      :measure_id.in => measures.pluck(:id),
      :population_set_key => pop_set
    ).only(:episode_results, :patient_id, :measure_id).to_h { |elem| [elem[key], elem.observed_values] }
  end

  def get_observation_values_by_population(records, measures, pop_set, key)
    CQM::IndividualResult.where(
      :patient_id.in => records.pluck(:id),
      :measure_id.in => measures.pluck(:id),
      :population_set_key => pop_set
    ).collect do |elem|
      [
        elem[key],
        elem.collect_observations
      ]
    end.to_h
  end

  # This method returns a hash of the form
  #  {BSON::ObjectId('1')=>{"IPP"=>1, "DENOM"=>0, "DENEX"=>0, "NUMER"=>0, "DENEXCEP"=>0},
  #  BSON::ObjectId('2')=>{"IPP"=>1, "DENOM"=>0, "DENEX"=>0, "NUMER"=>0, "DENEXCEP"=>0},
  #  BSON::ObjectId('3')=>{"IPP"=>1, "DENOM"=>0, "DENEX"=>0, "NUMER"=>0, "DENEXCEP"=>0},}
  #
  # Inputs:
  # correlation_id: The correlation_id used when performing the measure calculation, most like, the test exection id
  # file_name: The file name for the results you are looking for.
  # measures: An array of measures (If you only care about a single measure then pass in [measure])
  # pop_set: The population set identifier for the result set you care about, for example ['PopulationCriteria1']
  # pop_keys: The population keys which you care about, for example ['IPP', 'DENOM']
  # key: The name of the element which should be the key of the key value pair returned.
  # We currently use 'patient_id' and 'measure_id' as keys and then do lookups for the values
  # in the hash when generating miscellaneous views around the Master Patient List.s
  def get_result_values_for_patient(individual_results, patient_id, pop_keys, key)
    individual_results.select { |ir| ir.patient_id == patient_id }.collect do |elem|
      [
        "#{elem[key]}|#{elem['population_set_key']}",
        pop_keys.collect { |pop_key| [pop_key, elem[pop_key].to_i] }.to_h
      ]
    end.to_h
  end

  # This method returns a hash of the form
  #  {"606b4219c1c388103e35a23e|PopulationSet_1"=>[[9, 1]]}
  #
  # Inputs:
  # individual_results: An array of individual_results
  # patient_id: The id for the patient you care about
  # key: The name of the element which should be the key of the key value pair returned.
  def get_observation_values_for_patient(individual_results, patient_id, key)
    individual_results.select { |ir| ir.patient_id == patient_id }.to_h { |e| ["#{e[key]}|#{e['population_set_key']}", e.observed_values] }
  end

  def records_by_measure(records, measure, product_test, vendor)
    # When searching vendors or master patient list, there can be a lot of patients
    # if there is a vendor, use the correlation_id to filter Individual Results
    if vendor
      patient_ids = IndividualResult.where(correlation_id: vendor.id.to_s, measure_id: measure.id).pluck(:patient_id)
      records.find(patient_ids)
    # if there isn't a vendor, or product test, use the bundle correlation_id
    elsif product_test.nil?
      patient_ids = IndividualResult.where(correlation_id: measure.bundle_id, measure_id: measure.id).pluck(:patient_id)
      records.find(patient_ids)
    # otherwise, just return the list of patients
    else
      records
    end
  end

  def hide_patient_calculation?
    # Hide measure calculation if Cypress is in ATL Mode and the current user is not an ATL or admin
    Settings.current.mode_atl? && (!current_user.user_role?('admin') && !current_user.user_role?('atl'))
  end

  def population_label(bundle, pop)
    bundle.modified_population_labels && bundle.modified_population_labels[pop] ? bundle.modified_population_labels[pop] : pop
  end

  def measure_display_name(measure, population_set_hash)
    cms_id = measure.cms_id
    population_set_display = population_set_hash[:stratification_id] || population_set_hash[:population_set_id]
    "#{cms_id} - #{population_set_display.tr('_', ' ')}"
  end

  # creates a folder with html patient files and zipped html patient files
  def html_zip(patients, temp_path, name)
    path = Rails.root.join(temp_path, Time.now.in_time_zone.getutc.to_s)
    FileUtils.mkdir_p(path)

    mes, sd, ed = Cypress::PatientZipper.measure_start_end(patients)
    formatter = Cypress::HTMLExporter.new(mes, sd, ed)
    patients.each do |r|
      filename = "#{r.first_names}_#{r.familyName}.html".delete("'").tr(' ', '_')
      File.open(File.join(path, filename), 'w') do |f|
        f.write(formatter.export(r))
      end
    end
    zfg = ZipFileGenerator.new(path, Rails.root.join(temp_path, name))
    zfg.write
  end
end
