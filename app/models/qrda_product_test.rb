class QRDAProductTest < ProductTest
  
  
  #after the test is created generate the population
  after_create :generate_population
  
  def generate_population
    self.measures.each do |measure|
      Record.where({test_id: nil, measure_id: measure.id, type: :qrda}).each do |rec|
        cloned = rec.clone
        cloned.test_id = self.id
        cloned.save
      end
    end
    
  end
  
  
  
  def execute(params)
    file = params[:results]
    te = self.test_executions.build(expected_results: self.expected_results, execution_date: Time.now.to_i)
    te.execution_errors = Cypress::QRDAUtility.validate_zip(file)
    
    ids = Cypress::ArtifactManager.save_artifacts(file,te)
    te.files = ids
    te.save

    (te.count_errors > 0) ? te.failed : te.pass
    te
    
  end
  
  
  def self.product_type_measures
    Measure.top_level
  end
  
  
  
  
  # method used to mark the elements in the document that have errors so they 
  # can be linked to
  def match_errors(name)
    zp =  Cypress::ArtifactManager.save_artifacts(file,te)
    #read in the appropriate file entry
    file = zp.read_entry(name)
    doc = Nokogiri::XML(file.read)
    error_map = {}
    error_id = 0
    error_attributes = []
    locs = content_errors.collect{|e| e.location}
    locs.compact!

    locs.each do |location|
      # Get rid of some funky stuff generated by schematron
      clean_location = location.gsub("*:", '').gsub("[namespace-uri()='urn:hl7-org:v3']", '')
      node = REXML::XPath.first(doc , clean_location)
      if(node)
        elem = node
        if node.class == REXML::Attribute
          error_attributes << node
          elem = node.element
        end
        if elem
          unless elem.attributes['error_id']
            elem.add_attribute('error_id',"#{error_id}") 
            error_id += 1
          end
          error_map[location] = elem.attributes['error_id']
        end
      end
    end

    return doc, error_map, error_attributes
  end
end